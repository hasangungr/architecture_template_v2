Core 
    init - consts - base - components
    Bu katman bussines katmanlarının yapılacağı işlerin yönetildiği yer
    Bu katmanı taşıyabilmek önemli olandır yani başka bir projeye olduğu gibi taşıyabilmelisin

Test Core
    mock manager mock service

    Mock


streamBuilder?
    bir yeri dinliyor sadece dinlediği yerden gelene göre tetikleniyor



state class ?


reflection?



lifeCycle
with ?
mixin abstract implements extends 

store ? 
context ?
oNGenerateRoute ? 
SingleChildWidget ?
copywith? 
reflection?
 
inheritance
pods?
podfile?
 WidgetsFlutterBinding.ensureInitialized(); ??
 migration ?
 equatable ? 
 searchDelegate ?
 goRouter and routing navigator 3.0
image_picker ? 
super ?
 extends, implements
valueSetter

object vs dynamic 

factory

Navigator

mobx-mobx_codegen-flutter_mobx-build-runner






 

 
fiximport
Systemoverlay - appbar
didUpdateWidget 
inspect(this)
Statelesslar immutabledır değer alır değer verir bu yüzden finalsız kullanılmaz
Part of 


snippet: kendi custom snippetların
extension : o sınıfa özellik kazandırıyor, on dediğin sınıfı genişletiyor o sınıfa custom kendi özelliğini ekleyip nesnesi olmadan kullanabiliyorsun

Singleton yaklaşımı belirli bir sınıfın yalnızca bir örneğinin olmasını ve bu örneğe global olarak erişilmesini sağlar 

Abstract classlar genelde kalıtım yolu tercih edildiğinde 

Private cont: sınıfın herhangi bir örneğine ihtiyaç yoksa bir newleme söz konusu değilse kullanılır


Immutable??: değişmez classlar için const için kullanılır yani bir product editlenebilir değişebilir fakat bir kategori kategori değişmez vb gibibibbibi ????


WidgetsBinding.instance.addPostFrameCallback =>build metodu tamamlandıktan sonra Widget ağacı oluşur biter sonra işleme alınır 
future.microtask => Diğer future işlemlerinden önce işlenir


Stless vs func =final değişkenler ve const widgetlar için stless

Context.read sadece bir okuma yapar 
Context.watch dinler vb. Gibi consumer ile aynı işi yapar farkları yoktur context yoksa consumer kullanabilirsin


panache**


 



Performans Optimizasyonu: Sınıflar, daha ayrıntılı yeniden oluşturma ve const yapıcıları sayesinde performans optimizasyonu sağlar.
Güncellemeler ve Bellek Yönetimi: Sınıflar, geçişler sırasında kaynakların doğru şekilde serbest bırakılmasını sağlar.

-----------------
Feature - işler
Product - projenin ihtiyaçları
Core - projeden bağımsız logicler paket implements vs func
Common - padding vs package vs
Widgets - atomic widgets


*.ipa?



